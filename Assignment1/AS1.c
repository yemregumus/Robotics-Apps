#pragma config(StandardModel, "RVW SQUAREBOT")
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_inch)
#pragma config(Sensor, dgtl9,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl10, leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,  rightMotor,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,  leftMotor,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Moving Forward
This program instructs your robot to move forward at full power for a specified distance.
There are functions to turn the robot left and right using encoders.

Robot Model(s): Squarebot

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        rightMotor          VEX Motor             Right side motor
Motor Port 3        leftMotor           VEX Motor             Left side motor

----------------------------------------------------------------------------------------------------*/

#define k_start_to_firstTurn_distance_cm 250 //Distance to travel before the first turn (250 cm).
#define k_distance_after_first_turn_cm 150 //Distance to travel after the first turn (150 cm).
#define k_distance_to_last_turn_cm 250 //Distance to travel before the last turn (250 cm).
#define k_distance_after_last_turn_cm 125 //Distance to travel after the last turn (125 cm).
#define k_speed 127 //Speed at which the motors will run (127).
#define k_turning_ticks 365 //Encoder ticks required for a 90-degree turn (365).
#define k_threshold = 40;

#define d_ticks_per_rev 365  //Encoder ticks per revolution (365).
#define d_radius_cm_wheel 2.6 //Radius of the robot's wheel (2.6 cm)
#define d_pi 3.14 //Approximate value of pi (3.14).


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++

/*
Calculates the number of encoder ticks required to travel a specified distance.

Parameters: distance_cm - Distance in centimeters.
Returns: ticks - Number of encoder ticks.
*/
int calculate_ticks(int distance_cm){
	int ticks;
	float circumference = 2 * d_pi * d_radius_cm_wheel;
	ticks = (distance_cm / circumference) * d_ticks_per_rev;
	return ticks;
}


/*
Moves the robot forward for a specified distance at a specified speed.

Parameters:
distance - Distance to travel in centimeters.
speed - Speed of the motors.
Behavior:
Resets the encoder values.
Calculates the required encoder ticks for the given distance.
Runs the motors forward until the target encoder ticks are reached.
Stops the motors.
*/
void moveForward(int distance, int speed){
	//Clear Encoders
  SensorValue[rightEncoder] = 0;
  SensorValue[leftEncoder] = 0;

  int ticks = calculate_ticks(distance);

  while(SensorValue[leftEncoder] < ticks || SensorValue[rightEncoder] < ticks) {
  	motor[rightMotor] = speed;
  	motor[leftMotor] = speed;
  }

  // Stop motors
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
}


/*
Turns the robot left or right based on the specified direction and speed.

Parameters:
dir - Direction to turn ('l' for left, 'r' for right).
speed - Speed of the motors.
Behavior:
Resets the encoder values.
Turns the robot until the target encoder ticks are reached.
*/
void turn(char dir, int speed)
{
	//Clear Encoders
  SensorValue[rightEncoder] = 0;
  SensorValue[leftEncoder] = 0;

  if (dir =='l'){
  	while(abs(SensorValue[leftEncoder]) < k_turning_ticks){
  		motor[rightMotor] = speed;
  		motor[leftMotor] = -speed;
  	}}else if (dir =='r'){
  	while(abs(SensorValue[leftEncoder]) < k_turning_ticks){
  		motor[rightMotor] = -speed;
  		motor[leftMotor] = speed;
  	}
	}
}


/*
Controls the main logic for the robot's movement and turning sequence.

Behavior:
Continuously checks the sonar sensor for obstacles (stops if an obstacle is within 20 cm or the sensor is inactive).
While the touch sensor is not activated, performs the following sequence:
Moves forward k_start_to_firstTurn_distance_cm.
Turns left.
Moves forward k_distance_after_first_turn_cm.
Turns left.
Moves forward k_distance_to_last_turn_cm.
Turns right.
Moves forward k_distance_after_last_turn_cm.
*/
task main()
{

	while(SensorValue(sonarSensor) > 20 || SensorValue(sonarSensor) == -1){
		while(SensorValue(touchSensor) == 0){
			moveForward(k_start_to_firstTurn_distance_cm, k_speed);
			turn('l',127);
			moveForward(k_distance_after_first_turn_cm, k_speed);
			turn('l',127);
			moveForward(k_distance_to_last_turn_cm, k_speed);
			turn('r',127);
			moveForward(k_distance_after_last_turn_cm, k_speed);
}
}
}
